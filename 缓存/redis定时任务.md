## 前言
借助redis的某些特性，我们可以实现定时任务的功能，在某些场景下这是有用的，比如只是一个小功能，而我们系统又使用了redis，就可以考虑用它来实现，而不需要我们引入分布式调度中心类似的组件。
redis可以通过事件通知和Sorted Set数据结构来实现。
  
 ###  事件通知
 在redis.config配置文件开启 notify-keyspace-events 事件通知类型。
-  K  启用keyspace键空间通知，客户端可以使用keyspace@为前缀的格式使用订阅功能
-  E  启用keyevent键事件通知，客户端可以使用keyevent@为前缀的格式使用订阅功能
-  g  监控一般性事件，包括但不限于对del，expire，rename事件的监控
-  $  启用对字符串格式（即一般K-V结构）命令的监控
-  l  启用对List数据结构命令的监控
-  s  启用对Set数据结构命令的监控
-  h  启用对Hash数据结构命令的监控
-  z  启用对ZSet数据结构命令的监控
-  x  启用对过期事件的监控
-  e  启用对驱逐事件的监控，当某个键因maxmemory达到设置时，使用策略进行内存清理，会产生这个事件
-  A  别名 g$lshzxe参数别名（只是一堆参数的别名）

定义事件中必须包含 K或者E 否则都不会生效。例如： Ex 表示对过期事件的通知  
启动redis后，在客户端需要订阅  命令格式如下： 
``` 
   psubscribe __[keyspace|keyevent]@<db>__:[prefix]
   //订阅0号数据库中，所有的键变化事件，进行键空间通知
   psubscribe __keyspace@0__:*  
   //订阅0号数据库，所有的键变化事件，进行键空间通知和键事件通知
   psubscribe __key*@0__:*
   //以上都是需要服务端把事件开启才生效
   //如果同时订阅了键空间通知和键事件通知 那么也只会收到一条事件 键事件通知
``` 
缺点：
- 首先这些消息并没有持久化机制，属于即发即弃模式。也就是说它们不能像rabbimq中的消息那样保证持久化消息订阅者不会错过任何消息，无论这些消息订阅者是否随时在线。
- 由于本来就是即发即弃的消息模式，所以Redis也不需要专门制定消息的备份和恢复机制。也没有记录哪些客户端是否被通知过。
- 没有事务机制或者ack确认机制。丢失的通知可能性极大。不易排查。
- 但大量的订阅者来不及消费，容易消息堆积
- 开启订阅模式有一定的性能开销。影响redis的速度。
- 事件通知的时间并不准确。Redis 并不保证生存时间（TTL）变为 0 的键会立即被删除： 如果程序没有访问这个过期键， 或者带有生存时间的键非常多的话， 那么在键的生存时间变为 0 ， 直到键真正被删除这中间， 可能会有一段比较显著的时间间隔
事件通知适合不是很严谨的业务，丢失事件也不会带来严重的后果。需要配合适当的补救机制一起使用。

### Sorted Set
sorted set是一个有序的set，可以把时间作为score，添加到sorted中，消费者轮询，达到时间就触发任务执行。
当有生产者新的执行需要插入时，sortset 集合添加元素，并重新排序，表示新增定时任务。  
缺点：
- 不支持多节点或者多个消费者，无法横向扩展
- 需要有比较强的命名规则
轮询适合单节点跑的业务，并且不能有大规模的相同时间点的事件。否则有很明显的延迟。
