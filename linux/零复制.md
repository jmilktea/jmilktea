## 简介  
操作系统处于安全考虑设计，在系统层面上通常会分为用户空间和内核空间两部分，用户相关的程序通常都是运行在用户空间，只拥有该用户相关权限，当需要进行系统调用时，如读写磁盘数据，就需要切换到内核空间进行，操作系统内核才能直接与硬件设备接口直接打交道。当读写完数据时，需要把数据拷贝到用户空间，从内核切换回用户空间状态对数据进行处理。整个过程涉及到用户空间和内核空间的上下文切换和数据在两者间的拷贝，这是比较消耗性能的。我们知道多线程有个缺点就是频繁的线程切换会影响性能，这里也是类似道理。对于传统IO实际就是完整执行用户空间和内核空间上下文切换和拷贝数据的完整过程，而零复制并不是完全没有复制，而是减少上下文切换和拷贝的次数，提升性能。

![image](https://github.com/jmilktea/jmilktea/blob/master/linux/images/zero-1.png)  

- DMA拷贝  
上图中DMA拷贝负责从硬件设备加载数据到内核空间，如磁盘，网卡，这个拷贝过程是不需要消耗cpu资源的，由硬件设备自己完成，可以看做现代硬件设备上都有一个小型的芯片负责拷贝数据，这样可以节约机器本身的cpu资源。

## 传统IO
传统的IO是调用系统read(),write()函数进行读写数据，我们以从磁盘例如数据读取数据返回给客户端为例，整个过程如下：

![image](https://github.com/jmilktea/jmilktea/blob/master/linux/images/zero-2.png)  

1.应用程序调用系统read()函数，此时需要从用户态切换为内核态，准备读取数据
2.DMA拷贝将数据从磁盘加载到内核缓存区域
3.cpu把内核缓冲区的数据拷贝到用户缓存区，供用户进行处理，此时从内核态切换回用户态，read()函数返回
4.用户应用程序读取用户缓存区数据进行处理
5.调用系统write()函数，此时从用户态切换为内核态，准备写入数据
6.cpu把用户缓冲区数据拷贝到socket缓冲区，准备发送数据
7.DMA拷贝将socket缓冲区数据拷贝到网卡设备，进行发送
8.发送完成，从内核态切换回用户态，write()函数返回

可以看到整个过程传统IO需要4次上下文切换和4次拷贝，对于现在数据越来越大，并发越来越高的系统来说，很明显有性能影响。零复制的出现就是为了减少上下文切换和数据拷贝的次数，提升io性能，常见的零复制技术有mmap和sendfile。

## mmap  
mmap的全称是memory mapped files，它的原理是通过地址映射实现用户缓冲区和内核缓冲区的地址映射，这样就可以直接在用户空间直接访问数据，避免从内核缓存区拷贝数据到用户缓存区这个过程。整个过程如下：

![image](https://github.com/jmilktea/jmilktea/blob/master/linux/images/zero-3.png)  

1.应用程序调用系统mmap()函数，此时需要从用户态切换为内核态，准备读取数据
2.DMA拷贝将数据从磁盘加载到内核缓存区域
3.内核态切换回用户态，mmap()函数返回
4.用户应用程序根据地址映射，直接对内核缓冲区数据进行处理
5.调用系统write()函数，此时从用户态切换为内核态，准备写入数据
6.cpu把用户缓冲区数据拷贝到socket缓冲区，准备发送数据
7.DMA拷贝将socket缓冲区数据拷贝到网卡设备，进行发送
8.发送完成，从内核态切换回用户态，write()函数返回

可以看到mmap实际上是替换了read()函数，减少了一次数据拷贝的消耗。整个过程需要4次上下文切换和3次拷贝，相比传统IO节约了一次数据拷贝，在并发很高的情况下，节约一次数据拷贝系统的性能提升也是很可观的。

## sendfile  
sendfile是linux内核2.1版本后内核新提供的一个函数，它可以不在用户和内核空间拷贝数据，直接通过内核空间将数据发生出去。过程如下：

![image](https://github.com/jmilktea/jmilktea/blob/master/linux/images/zero-4.png)  

1.应用程序调用系统sendfile()函数，此时需要从用户态切换为内核态，准备读取数据
2.DMA拷贝将数据从磁盘加载到内核缓存区域
3.cpu把用户缓冲区数据拷贝到socket缓冲区，准备发送数据
4.DMA拷贝将socket缓冲区数据拷贝到网卡设备，进行发送
5.发送完成，从内核态切换回用户态，sendfile()函数返回

可以看到sendfile整个过程只需要2次上下文切换和3次拷贝，相比传统IO节约了2次上下文切换和一次拷贝。但由于没有把数据拷贝到用户空间，所以sendfile只适合用户程序不需要对数据进行处理的场景。

## sendfile scatther/gather  
linux内核2.4版本后对sendfile进行优化，主要是优化从内核缓存区拷贝到socket缓存区这个过程，这样再次节约cpu资源。过程如下：

![image](https://github.com/jmilktea/jmilktea/blob/master/linux/images/zero-5.png)  

1.应用程序调用系统sendfile()函数，此时需要从用户态切换为内核态，准备读取数据
2.DMA拷贝将数据从磁盘加载到内核缓存区域
3.将缓冲区数据元信息（主要是数据长度和偏移量）拷贝到socket缓冲区，准备发送数据
4.DMA拷贝将socket缓冲区数据拷贝到网卡设备，进行发送
5.发送完成，从内核态切换回用户态，sendfile()函数返回

可以看到，优化后的sendfile只需要拷贝少量的数据大小和偏移这类元数据信息到socket缓冲区即可，不再需要拷贝整个数据，这样可以更好的节省cpu资源，scatther/gather需要硬件设备的支持。

## 总结  
零复制技术的核心都是为了减少操作系统的上下文切换和数据拷贝的次数，在并发量很高的场景下，对系统的性能有很大的帮助。例如分布式系统都会引入消息中间件做异步操作，现在系统的消息量都是非常大的，频繁的切换和数据拷贝会影响消息的实时性。rocketmq的读写数据就是通过[mmap+write](https://github.com/apache/rocketmq/blob/master/docs/cn/design.md)的方式进行，而kafka也使用mmap+write进行数据写入，对于消费数据使用的是sendfile。
