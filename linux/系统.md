## 系统负载 
**命令：top**   
描述：top 可以查看机器负载情况，在排查问题的时候经常会用到  
![image](https://github.com/jmilktea/jmilktea/blob/master/linux/images/top.png)  
输出概要信息包含**系统信息**，**进程信息**，**cpu信息**，**物理内存信息**，**交换区内存信息**：  
**top**：09:44:56 [当前系统时间], 16 days[系统已经运行了16天], 1 user[个用户当前登录], load average: 9.59, 4.75, 1.92[系统负载，即任务队列的平均长度]  
**Tasks**: 145 total[总进程数], 2 running[正在运行的进程数], 143 sleeping[睡眠的进程数], 0 stopped[停止的进程数], 0 zombie[冻结进程数]    
**Cpu(s)**: 99.8%us[用户空间占用CPU百分比], 0.1%sy[内核空间占用CPU百分比], 0.0%ni[用户进程空间内改变过优先级的进程占用CPU百分比], 0.2%id[空闲CPU百分比], 0.0%wa[等待输入输出的CPU时间百分比], 0.0%hi[], 0.0%st[]    
**Mem**: 4147888k total[物理内存总量], 2493092k used[使用的物理内存总量], 1654796k free[空闲内存总量], 158188k buffers[用作内核缓存的内存量]  
**Swap**: 5144568k total[交换区总量],56k used[使用的交换区总量],5144512k free[空闲交换区总量],2013180k cached[缓冲的交换区总量]
- 操作
  - 按下P控制台会按照%CPU排序
  - 按下M则会按照内存排序
  - 按下q则退出
  - 使用-p 参数可以查看指定进程  
  如 top -p 8963查看java进程的使用情况
- htop   
需要安装，更方便，强大一些

## 磁盘/目录
**命令：df(disk free)，du（disk usage）**
- df 查看磁盘使用情况  
df -h：-h表示以可读形式输出，例如1G,200M代替字节输出如下：  
![image](https://github.com/jmilktea/jmilktea/blob/master/linux/images/df.png)  
**Filesystem**:表示文件系统名称  **Size**:大小  **Used**:已用大小  **Avail**:可用空间  **Use**%:已用百分比  **Mounted on**:挂载点  
从上面可以看到vda1这个盘挂载在/根目录下，并且已用100%，没有剩余空间了

- du 查看目录文件使用情况  
  - **查看某个文件或目录大小：du -h 目录/文件名**  
  没有写文件名则表示当前目录    
  
  - **查看当前目录下所有目录大小：du -sh \***   
  -s表示汇总，而不输出子目录    
  
  - **查看当前所有目录大小并排序：du -sh * | sort -h**   
  sort -h表示依照可读大小排序   
  
  - **查看当前目录下最大的10个目录：du -sh * | sort -rh | head -n 10 或者 du -sh * | sort -h | tail -n 10**    
  sort -r表示倒序，head -n 取前n个  
  
  - **查看占用最大的10个文件：find / -type f -print0 | xargs -0 du -h | sort -rh | head -n 10**   
  上面的输出都是基于目录，如果我们想要查找文件单纯使用du无法使用，需要结合一下find，命令看起来比较复杂，也是面试经常会问到的  
  find / -type f：表示在/目录下查找文件类型     
  -print0：表示将null作为分隔符，而不是空格或换行符    
  xargs：是一个参数过滤器，-0表示用null分隔，这里相当于把find的结果通过null分隔得到结果，然后传给du命令，后面的就和使用du命令一样了      
 
## 内存
**命令：free**   
参数介绍：  
 - h：内存显示会自动适配单位，内存使用适配单位来显示（带单位，常用）。
 - g：内存显示会适配GB单位，内存使用GB来显示。
 - m：内存显示会适配MB单位，内存使用用MB来显示。
 - k：内存显示会适配kb单位，内存使用用kb来显示(默认显示)。
 - b：内存显示会适配字节单位，内存使用用字节来显示。
 - s：刷新的时间，单位秒。输出结果是累加后面的。
 - t：会增加一行显示系统总内存/使用/剩余  
**例如：我们输入 free -h -s 1(一秒刷新内存使用情况)**
![image](https://github.com/jmilktea/jmilktea/blob/master/linux/images/free.png)
 - Mem：当前系统内存的使用情况。
 - Swap：交换空间（虚拟内存，硬盘当内存使用）的使用情况。解释：当物理内存不够使用，系统会开辟硬盘空间来当系统内存使用（windows也有）。经常不使用的进程就会从物理内存挪到swap中。如果该进程重新唤醒的时候，又会重新加载到物理内存中。当物理内存充足，swap空间大小是 0
 - total：系统的物理内存大小/交换空间内存大小
 - used：已使用物理内存大小/交换空间内存大小
 - free：剩余物理内存大小/交换空间内存大小。可以理解空闲内存，未开发的内存。并不是当前系统可用内存
 - shared：多个进程共享的内存总额
 - buff/cache；buffer和cache使用的物理内存大小。
 - available：还可以被应用程序使用的物理内存大小(内存已经被系统征用)  
**想跟top那样持续更新内存信息可以使用命令：watch free -k**
**free命令输出的信息来源于 cat /proc/meminfo 文件，这个文件存储了系统资源使用情况**

**内存回收>手动回收**    
**修改drop_caches参数。echo 参数 > /proc/sys/vm/drop_caches或者 cat /proc/sys/vm/drop_caches 参数**
 **参数值说明:**
 - 0:不释放（系统默认值），系统自动分配内存
 - 1:释放页缓存
 - 2:释放dentries和inodes
 - 3:释放所有缓存   
**手动执行 sync 命令，执行后free -h查看是否回收内存。再echo 0 > /proc/sys/vm/drop_caches或者cat /proc/sys/vm/drop_caches 0设置回去。让系统重新分配内存**
**手动内存回收只针对内存不够/Swap虚拟内存过大的时候进行使用。**  
  ## docker容器查看内存使用情况
**docke容器运行在docker中。但是所有的容器共享内核。每个容器在系统中对应一个进程。找出对于的进程即可查看内存使用情况**
![image](https://github.com/jmilktea/jmilktea/blob/master/linux/images/docker-ps.png)
**docker stats命令。这个命令有点像top的味道。也是不停的在刷新（1S）内存CPU使用情况**
![image](https://github.com/jmilktea/jmilktea/blob/master/linux/images/docker-stats.png)
信息介绍：
 - CONTAINER：容器id.
 - NAME：容器名称
 - CPU%：CPU使用情况
 - MEM USAGE / LIMIT：当前使用内存/最大使用内存（无设置则是系统最大内存）
 - MEM %：百分比显示内存。上面两个参数相除
 - NET I/O：网络IO
 - BOLCK I/O；磁盘IO
 - PIDS：PID 号 
命令介绍：
 - no-stream：无须持续刷新
 - 容器ID：只查看想看的容器。输入容器ID即可。多个容器id空格隔开
 
## 进程
**命令：ps，查看系统进程，使用 BS 操作系统格式**   
参数介绍：  
 - a：显示一个终端的所有进程，除会话进线外
 - u：显示进程的归属用户及内存的使用情况
 - x：显示没有控制终端的进程
 - l：长格式显示更加详细的信息
 - e：显示所有进程  
**例如：我们经常查询java的运行情况：ps aux |grep java**
![image](https://github.com/jmilktea/jmilktea/blob/master/linux/images/ps.png)
以上是ps aux列出所有进程其中：
 - user：进程运行的用户
 - PID：进程的ID
 - %CPU：当前使用的CPU百分比
 - MEM：该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源
 - VSZ：该进程占用虚拟内存的大小，单位为 KB。
 - RSS：该进程占用实际物理内存的大小，单位为 KB。
 - TTY：该进程是在哪个终端运行的
 - STAT：进程状态.S
 - START：该进程的启动时间
 - TIME：该进程占用 CPU 的运算时间，注意不是系统时间
 - COMMAND：该进程启动的shell命令  
**其中 | 是linux的缓存区管道，前面命令产生的输出流通过管道进入 grep命令进行分组。**
**筛选出含有java的进程。（一般搜索启动命令COMMAND）就可以快速找到我们想要的进程**
进程的状态 STAT :
- D：无法中断的休眠状态（通常 IO 的进程）
- R：正在运行可中在队列中可过行的
- S：处于休眠状态
- T：停止或被追踪
- W：进入内存交换
- X：死掉的进程
- Z：僵尸进程

**进程的 STAT 描述:**
- <：优先级高的进程
- N：优先级较低的进程
- L：有些页被锁进内存
- s：进程的领导者（在它之下有子进程，注意这个是小写s。与上面状态S不同）
- l：多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）
- +：位于后台的进程组

**例如：S<：优先级高的休眠状态的进程。Ss：拥有子进程的休眠进程**
**命令：kill[参数] [进程号] 操作进程**
**发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程**
参数：
 - l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称
 - a  当处理当前进程时，不限制命令名和进程号的对应关系
 - p  指定kill 命令只打印相关进程的进程号，而不发送任何信号
 - s  指定发送信号
 - u  指定用户

注意：

1、kill命令可以带信号号码选项，也可以不带。如果没有信号号码，kill命令就会发出终止信号(15)，这个信号可以被进程捕获，使得进程在退出之前可以清理并释放资源。也可以用kill向进程发送特定的信号。例如：

kill -2 123

它的效果等同于在前台运行PID为123的进程时按下Ctrl+C键。但是，普通用户只能使用不带signal参数的kill命令或最多使用-9信号。

2、kill可以带有进程ID号作为参数。当用kill向这些进程发送信号时，必须是这些进程的主人。如果试图撤销一个没有权限撤销的进程或撤销一个不存在的进程，就会得到一个错误信息。

3、可以向多个进程发信号或终止它们。

4、当kill成功地发送了信号后，shell会在屏幕上显示出进程的终止信息。有时这个信息不会马上显示，只有当按下Enter键使shell的命令提示符再次出现时，才会显示出来。

5、应注意，信号使进程强行终止，这常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。发送信号时必须小心，只有在万不得已时，才用kill信号(9)，因为进程不能首先捕获它。要撤销所有的后台作业，可以输入kill 0。因为有些在后台运行的命令会启动多个进程，跟踪并找到所有要杀掉的进程的PID是件很麻烦的事。这时，使用kill 0来终止所有由当前shell启动的进程，是个有效的方法。

说明：

只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略。 下面是常用的信号：

HUP    1    终端断线

INT     2    中断（同 Ctrl + C）

QUIT    3    退出（同 Ctrl + \）

TERM   15    终止

KILL    9    强制终止

CONT   18    继续（与STOP相反， fg/bg命令）

STOP    19    暂停（同 Ctrl + Z）

例如：杀死某个用户下的所有进程：kill -9 $(ps -ef | grep 用户名)（init进程不可终止，用户的内核进程。）
