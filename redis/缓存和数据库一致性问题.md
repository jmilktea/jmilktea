## 前言   
缓存是一个高并发系统必不可少的一个组件，它可以减少直接对数据库的访问，由于数据直接缓存在内存中，所以访问速度很快，以redis为例，支持单机10W+的qps。有了缓存，我们的读取过程如下：  
![image](https://github.com/jmilktea/jmilktea/blob/master/redis/images/read-cache.png)   
凡事都有两面性，缓存为我们带来了响应速度的提升，也带来一些缺点。例如，系统的复杂性增加了，还有数据一致性问题。我们看到读取的过程是没什么问题的，但对于数据的修改，先更新缓存还是先更新数据库，在网络异常和多线程并发下，就会产生不一致的问题，对于分布式系统，数据一致性是个常见的话题，我们看下对于数据的修改有哪些解决方案。  

## 解决方案  
对于数据的修改，有如下几种操作方式：  
1.先更新缓存，再更新数据库  
2.先更新数据库，再更新缓存  
3.先删除缓存，再更新数据库  
4.先更新数据库，再删除缓存     
每种方式在正常的情况下都是没问题的，但是在其中一个操作失败时问题就会很明显，失败的情况也很多，如网络问题，redis触发拒绝写入限制，更新数据库失败，获取数据库链接失败等，除此之外，还要考虑**多线程操作**，**主从同步**等场景，也都可能导致缓存和数据库数据不一致，当然实际实施我们还需要考虑**性能和复杂性**等问题。我们逐个看每种操作方式有什么优缺点。    

1.**先更新缓存，再更新数据库**   
这种方案问题非常明显，如果更新数据库失败，那么在缓存过期时间内，读到的数据都是脏数据，这个数据也可能是异常数据，导致数据库更新失败，此时缓存异常的数据会对业务造成影响。

2.**先更新数据库，再更新缓存**    
既然1可能缓存到错误的数据，那反过来先更新数据库呢，先确保数据更新成功。  
在多线程操作下，数据库的值是以最后操作那个为准，缓存的值又以数据库的为准。这种方式在多线程下，可能出现在B更新缓存后，A再更新缓存，出现脏数据。如下：    
(1)A更新数据库成功  
(2)B更新数据库成功  
(3)B更新缓存成功  
(4)A更新缓存成功  

这种情况在多线程下应该非常容易复现。同时，使用更新缓存的方式还有一个问题，如果缓存的数据是需要经过计算才能获得的，那也就意味着每次都需要耗时去计算，但是更新缓存后，并不一定会马上被读到，写多读少的系统会更明显。考虑到读取的过程，缓存的加载应该是懒加载，需要的时候再读取，所以更新缓存的方式一般不会被考虑。既然更新不可取，那直接删除不就行了。

3.**先删缓存，再更新数据库**     
这种方式，如果更新数据库失败也没有影响，缓存读取时会重新加载。这种操作可能出现不一致的场景是：  
(1)A删除缓存   
(2)B读取缓存不存在  
(3)B读取数据库得到旧值  
(4)B设置旧值到缓存  
(5)A更新数据库    
此时缓存的仍是旧数据，得等到过期才加载新值  

4.**先更新数据库，再删除缓存**   
这种方式其实就是**cache aside pattern**，翻译过来就是：**旁路缓存模式**，是facebook提出的一种策略。这种策略的读过程和上面的一致，而写过程就是先更新数据库，再删除缓存。但这种模式也不是完美的，可能出现不一致的场景：  
(1)缓存刚好过期    
(2)A查询数据库，得到一个旧值  
(3)B更新数据库  
(4)B并删除缓存  
(5)A将旧值写入缓存   
此时缓存的仍是旧数据。另外先更新数据库成功，删除缓存失败，此时数据也会不一致。  
看起来和方式3差不多，实际有一个概率问题，使用该方式出现不一致的概率一般要比3小，首先缓存要刚好过期。其次，(3)的耗时要比(2)更短，才能使得(4)先于(5)执行，但一般读的速度会快于写，所以这种情况出现不一致的概率会较低。

## 讨论  
从上面的几种方式比较可以看出，更新缓存的做法不会被使用，而删除缓存的方式也可能出现不一致的场景。从上面使用缓存的原则可以看出，实际没有多少情况，我们是强求一致性的，这有点类似于分布式系统中，我们追求的是最终一致性，而删缓存的方式可以达到这种效果。接下来我们讨论下还有哪些场景

1.主从同步  
如果是主从同步，缓存读取是从从库读，那可能因为主从同步延迟导致读取的仍然是旧数据，网上有的做法是更新数据库后，延迟一个合理时间，等待主从同步完成后再删除缓存。但这种情况比较不可控，可能正常的延迟时毫秒级别，但可能由于要同步的数量太大，变成几秒或者几分钟，这种情况实际项目中比较常见。有两种方式对待这个问题，一是强制读主库，牺牲主库的性能；二是允许读到旧数据。    

2.延时双删策略  
```
redis.delKey(key); 
db.updateData(data);
Thread.sleep(500);
redis.delKey(key);  
```
这种做法看起来是将3,4两种方式结合了，中间sleep了500ms就是避免多线程并发的场景，该时间内缓存可能再次被加载，短时间出现不一致，但后面会再次删除。这种做法一般不推荐，因为sleep降低了系统量(当然可以使用异步线程等待)，500ms这个时间不好把控；此外还需要多一次删除redis，系统复杂性增加，深入考虑还要确保第二次删除缓存成功才行。  

3.使用canal  
从上面可以看到整个过程的主要矛盾点在于要同时操作缓存和数据库，通过canal订阅binlog，可以把删除缓存这个操作延后，过程如下：   
![image](https://github.com/jmilktea/jmilktea/blob/master/redis/images/canal-refresh-cache.png)     
这种方式的缺点也很明显，需要引入canal中间件，复杂性增加了不少，另外canal订阅binlog的时间也可能延迟，这个时候缓存的依然是旧数据。

## 总结  
可以看出，要保证缓存和数据库一致性需要付出很大的代价，这有点类似于CAP理论，要保证一致性就要牺牲可用性，鱼和熊掌不可兼得。
**数据的正确性是以数据库为准的，理想情况下是缓存和数据库的数据是一致的，但现实中多数情况下，我们允许缓存有一个时效性，暂时是旧的数据也没问题，等到过期，加载正确的数据。但不允许缓存的是错误的数据，而数据库里是正确的数据。**
结合实际场景，推荐使用的方式是：给缓存设置一个合理的过期时间 + 使用cache aside pattern(更新数据库，再删除缓存)。这种方式可以满足大多数的业务场景了，对于要求完全一致的是特殊场景，这种方式也只有在小概率的异常情况下才会出现不一致，这个时候再人工介入处理就行了。

